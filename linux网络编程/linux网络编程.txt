1. <sys/epoll.h>  #epoll  IO多路复用技术
   int epoll_create(int sz); 
   int epoll_ctl(int epfd, int opt, int sock, struct epoll_event*ev); 
   int epoll_wait(int epfd, struct epoll_event* evs, int max, int timeout); 
   opt :  EPOLL_CTL_ADD, EPOLL_CTL_MOD,  EPOLL_CTL_DEL
   struct epoll_event{
	int events;  # EPOLLIN  , EPOLLOUT, EPOLLERR, 
                struct epoll_data data;
   };
   struct epoll_data{
	int fd;
 	void *ptr; 
	uint32  u32; 
	uint64  u64;
 };

2. <sys/types.h>  <socket.h>  <unistd.h>  <netinet/in.h> <arpa/inet.h>
   int socket(int family, int type, int protocol); 
   int bind(int sock, struct sockaddr* addr, int  len); 
   int listen(int sock, int backlog); 
   int accept(int sock, struct sockaddr *addr, int *len); 
   int connet(int socket, struct sockaddr_int *addr, int len); 
   struct sockaddr; 
   struct sockaddr_in; 
   int htons(short port); 
   int inet_aton(const char* host, struct sin_addr* addr, int len); 
   memset(); 


3. <netdb.h> 
   struct addrinfo;
   int getaddrinfo(const char * host, const char *service, struct addrinfo* ai_hints, struct addrinfo**ai_result); 
   void freeaddrinfo(struct addrinfo* ai_hints); 
   int gai_stderror(int errno); 

4. int setsockopt(); 

5. close(), shutdown()的区别。

6. 动态链接库dlopen函数的使用。 
   dlopen, dlsym, dlclose，dlerror。 
   #include <dlfcn.h>
   void * dlopen(const char *path, int mode); #以指定的模式打开指定的动态链接库， 并返回一个句柄给调用进程。 
   调用成功， 返回库引用。 
   调用失败， 返回NULL。 
   void * handle = dlopen("xx.so", RTLD_LAZY); 
   编译时加入 -dl （指定dl库）
   void *dlsym(void *handle, const char* symbol); # 根据动态链接库句柄handle的操作， 以及链接库的函数名symbol， 返回该函数的地址。 
   返回结果相当于一个函数指针。 
   int dlclose(void *handle);  #关闭句柄的动态链接库， 只有动态链接库的使用计数为0时， 才会被系统卸载。 
   const char * dlerror(void);  #当动态链接库操作函数执行失败时， dlerror返回错误信息， 返回NULL表示函数操作成功。 













