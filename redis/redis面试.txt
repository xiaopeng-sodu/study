1. 什么是redis持久化？redis有哪几种持久化方式？优缺点分别是什么？
   redis持久化是将内存数据落地到磁盘的过程。 redis是内存型数据库， 数据存在内存里， 服务器宕机，发生灾难， 数据全部丢失。 
   所以要采取一定的策略定时或者以一定的条件将数据写进磁盘， 保障数据的安全性。 当服务器重启时， 将磁盘文件的数据重新加载到内存。 
   虽然redis持久化策略对数据有一定的保障， 但是没有达到数据的绝对安全， 会造成少量数据的丢失。 

   有aof 和 rdb 两种持久化方式。 

   rdb 全名 redis database。 
   rdb 是将某一个时刻内存的数据的记录下来，进行快照， 写入磁盘。 
   rdb是快照方式来持久化， 在某一个时刻快照内存， 将某一个时刻内存里的数据，进行磁盘IO，放置在磁盘上。 
   rdb是通过fork一个子进程处理内存里的数据，将内存数据写进一个临时文件，等数据写完之后，用临时文件替代之前的rdb.dump文件。 
   子进程负责将内存数据写入临时文件，主进程仍然响应客服端的请求。 这样极大的提高了redis的性能。 1G的内存大约需要20-30秒。 

   rdb持久化有两个方式， save 和 bgsave。 
   save命令  利用主线程处理，是同步操作，对于大量数据的操作会造成服务器的假死现象， 客服端的请求会响应延迟严重。 （避免使用）
   bgsave命令  fork一个子进程， 异步操作， 利用子进程处理内存数据到临时文件的落地，再用临时文件替换之前的rdb.dump文件。
   利用子进程进程处理内存的快照， 不会造成客户端的阻塞现象。
 
   优点。 适合灾难备份。 适合大量数据集的情况。 最大化redis的性能， 父进程fork的子进程， 子进程复制IO操作。 
              rdb是一个非常紧凑的文件， 保存了某一个时间点的数据集， 非常适合备份。 
   缺点。 对于不满足触发rdb落地条件的情况下，会造成这段时间里的数据丢失。 对于数据完整性要求较高的情况， 不推荐使用。 

   rdb的配置， 触发 条件。  
   dbfilename = dump_6379.rdb  #快照文件名
   dir = "./"  #放置目录
   save  900 1   #在900s内，至少有一次写操作，进行快照。 
   save  300 10  #300s内， 至少有10次写操作， 进行快照。 
   save  60 10000   #60s内， 至少有10000次写操作， 进行快照。 
  
   aof 全名append of file。 
   aof以日志的形式记录redis的每一个写操作， 不记录读操作， 使用追加文件的方式， 不可以改写文件。 
   aof 是记录每一次写操作。 将每一个写操作记录在磁盘里， 这样会减少了数据的丢失。 
   如果rdb.dump 和 appendfsync.aof 文件同时存在时， 默认使用appendfsync.aof文件， 也就是当两种持久化方式都开启的时候， 默认使用
   aof方式进行持久化。 
   优点。 数据更加安全。 
   缺点。 性能差于rdb， aof文件比rdb文件大。 

   重写机制。 
   aof文件以追加的方式写入， 这样文件会越来越大。 以重写的方式减少文件的大小。 例如对同一个键值写操作，只记录最后一次写操作， 删掉
   之前的写操作。 
   auto-aof-rewrite-percentage 100  
   auto-aof-rewrite-min-size  64m
   重写的触发机制：当前aof文件比上一次重写时aof文件大小增加了1倍， 并且aof的文件大于64m， 会触发重写机制。 

   aof 的配置， 触发条件。 
   appendonly = yes
   appendfilename "appendonly_6379.aof"   #aof持久化文件。 
   appendfsync always   #对每一个写操作都会追加。 数据最完整， 性能最差。 
   appendfsync everysec   # 每一秒钟追加一次。 最大可能会丢失1秒内的数据。折中的做法。 （一般会使用这种策略）
   appendfsync  no    # 根据系统来追加，一般是30s。 数据的完整性最差， 性能最好。 
  
2. 缓存雪崩， 缓存穿透， 缓存击穿， 热点key。 
   客户端请求查询key值时，先从缓存中查找， 若找到返回数据。 若缓存中没有， 再从数据库中查找， 若在数据库中找到，将数据存在缓存中，并
   返回数据给客户端。 若在数据库中没找到， 则返回错误信息。 

   缓存穿透：客户端请求查询，这个数据在缓存中不存在，进入db中查找， 在db中也不存在， 则返回错误信息。 如果发起大量非法的key值，在redis
   中没有，这些非法key全部打在db上，瞬间造成服务器的巨大压力，甚至造成服务器宕机； 
   解决方案：1. 使用布隆过滤器， 将非法的key值， 通过hash映射到bitmap中， 非法请求key值时， 利用布隆过滤器进行拦截， 避免请求打在db上。 
                   2. 对于非法key值， 也就是在redis和db中都不存在的key值， 在redis中设置一个标志，标志位无效值。 
  
   缓存击穿：瞬间涌入大量的请求， 对同一个key值得请求， 这些请求在redis中无法命中， 就请求db。 导致服务器的压力过大，甚至宕机。 
   解决方案：通过加锁或者队列的方式防止大量请求透过redis打到db上。 
                   对一些热点key， 过期时间可以调到无限长。 

   缓存雪崩：在一段时间里， 缓存key集中失效即大量的key同时失效， 并且这些key在同时被大量的并发请求， redis无法命中，直接落在数据库上。 
   解决方案：加锁或者队列。 
                   二级缓存。 A1为原始缓存， A2为备用缓存， A1失效时， A2顶上。 A1设置的有效时间较短， A2设置的有效时间较长。 

   缓存降级， 缓存预热， 缓存更新。 

   参考博客：https://www.cnblogs.com/xichji/p/11286443.html

3. 什么是redis的过期策略？redis的过期策略有哪些？
    设置过期时间的命令：expire  key  time  (时间单位：s， 秒）。 string 类型。 setex   key   seconds   value。 
    定时删除：为key设置过期时间， 也就是为key创建了一个定时器， 时间到了之后， 将会删掉key的数据。 
    优点：保证内存可以很快被释放。 
    缺点：定时器本身是对资源的一个很大的消耗， 大量的定时器， 将会造成CPU的巨大的消耗。 

    惰性删除：设置了过期时间的key， 等到时间到了之后， 不立刻删掉， 等待从数据库获取key的时候， 检查key是否过期， 过期了则删掉。 
    优点：减少了定时器的使用， 内存是被动的释放， 从而减少了CPU的使用。 
    缺点：若大量的key在过期之后， 若之后不再访问这些过期的key了， 将会造成内存泄漏。 

    定期删除：每隔一段时间，执行一次删掉过期的key值。 
   
   定时删除和定期删掉都是主动删掉， 对CPU的消耗挺大。 
   惰性删除是被动删除， 用到的时候检查key是否过期。 

   redis采用的过期策略是： 惰性删除 + 定期删除。 

   redis定期删除的配置：hz 10 ， 每1秒钟执行10次， maxmemory  100,  当已经使用的内存超过这个值时， 就会定时触发清理策略。 


4.  redis的高可用方案有哪些？各自的原理是什么？什么时候怎么集群不可用？


5.  使用redis实现一个异步消息队列？


6.  使用redis实现一个分布式锁？























