
mysql主要分 索引， 事务， 日志， 锁， 操作命令和内置函数，  性能优化和分布式。 

1. drop , truncate , delete 的区别？

    DML是数据操作语言。 DDL是数据定义语言。 
    delete是DML, 是有回滚日志, 记录下undolog里面。 
    truncate是DDL， 没有回滚日志， 一旦删掉数据，不可恢复。 
    drop是删掉表结构和表数据，是DDL， 没有回滚日志， 不可以恢复。 

2. innodb 和 myisam 的区别？

   innodb是行级锁。 myisam是表级锁。 
   innodb支持事务。 myisam不支持事务。 
   innodb适合大量的写入操作，并发度高。 

3. 聚集索引和非聚集索引的区别？

    聚集索引顾名思义索引和数据聚集在一起。 
    索引的逻辑顺序和数据块的物理顺序一致。例如索引1，2，3。对应的数据块在物理顺序上是连续的。 查询数据的时候，不是直接在磁盘上查找
    某一个索引对应的数据，是找到对应的数据页，将数据页加载到内存里，然后在内存里用二分查找法查找对应的value。 
    关系型数据库如此得名。 查找某一个key对应的value时，其附近的key的数据也可能会查到。附近的数据会随着整个页加载到内存里。 
    非聚集索引就是索引的逻辑顺序和数据块的物理地址不是连续的。 包括普通索引， 唯一索引， 全文索引，外键索引。 
    非聚集索引的叶子节点存放的是主键索引的值。索引使用普通索引查找的时候， 需要进行二次查找。 先找到对应的主键，然后找到对应的数据。

4. B树和B+树的区别？

    b树的非叶子节点存放数据。 b+树只在叶子节点存放数据。 

5. 主从复制的原理？

        mysql主从复制就是把主服务器的数据复制到从服务器上。
        master服务器的所有写操作记录在binlog，是一个二进制文件。 slave服务器将binlog日志从master服务器拷贝过来，执行，就完成对master服务器
   数据的同步。 
        完成主从复制需要3个线程：master的binlog-dump线程， slave的IO线程和sql线程。 
        slave与master建立连接。 master的binlog-dump线程将binlog日志通过socket传输通道传送到slave。slave接受到binlog后，使用IO线程将binlog
   存入relaylog， 然后sql线程执行relaylog，完成对数据的同步。 
        1. slave服务器连接master服务器，建立一条传输通道socket。 
        2. master服务器产生一条binlog-dump线程，将binlog日志传输到slave。 
        3. slave接收到binlog，产生一条IO线程，负责将binlog日志重做，转换成可执行的sql语句，并存放在relaylog。
        4. slave产生一条sql线程，负责执行relaylog的sql语句。 
   mysql的主从复制包含3种线程，2种日志。 binlog线程， io线程， sql线程。 binlog日志， relaylog日志。 

6. mysql有哪几种日志？

    1.  binlog， 二进制日志， 记录所有写操作。主要用于主从复制。 属于mysql-server层。 逻辑日志。 
    2.  redolog ，重做日志， 属于物理日志，是对物理页的修改。 属于引擎层innodb。 
    3.  undolog，回滚日志， 属于引擎层。 
    4.  relaylog， 中继日志，  是binlog日志的转换， 用于主从复制功能。 
    5.  errorlog ，错误日志。 
    6.  slow-query-log, 慢查询日志。 
    7.  gernel-log, 一般日志。 

7. 事务的几种特性？几种隔离级别？什么是脏读，不可重复读， 幻读？
  
    ACID。
    原子性，一致性， 隔离性， 持久性。
 
    脏读，B事务读取了A事务未提交的数据，然后，A事务回滚了。 
    不可重复读， A事务在两次读取某条数据时，在两次读取间隔之中， B事务对数据进行了修改，导致两次读取的数据不一致。 
    幻读， A事务在查询某张表的时候， 然后B事务对这张表插入了数据， A事务在未提交前，再次查询这张表，发现数据不一致，某一条数据从无到有，产生了幻觉一样。 

    事务的隔离级别。 
    read-uncommitted， 读未提交。 例如A事务读取了B事务未提交的数据。 可能产生脏读， 不可重复读， 幻读问题。 
    read-commited， 读提交。 例如A事务读取B事务已经提交的数据。读提交可以解决脏读，但存在不可重复读和幻读的问题。 
    repeatable-read , rr, 可重复读。 意思是一个事务不管执行时间有多长，读到的数据都是一致的。 要么读到是未提交的数据，要么读到的已经提交的数据。 
    可串行化，每一个事务都是串行化执行，不存在并发访问的可能。 
   
8. mysql有哪几种线程？

    binlog-dump线程
    io线程
    sql线程

9. mysql的三大范式是什么？

    原子性。 表的每一列必须具有原子性，不可再拆分。 
    唯一性。 表的每一列必须与主键有唯一的关系， 一张表只能描述一件事情。 
    每一列与主键是直接关系，不是间接关系。 与其他表可以通过外键联系。 

10. mysql有哪几种锁？

11. MVCC的原理？
       
       一个事务，不管其执行多长时间，其内部看到的数据是一致的。
       相关博客：https://www.cnblogs.com/myseries/p/10930910.html
       对于每一个事务都存在一个版本号。 这个版本号逐渐递增。 
       对于事务的每一个行数据都存在两个字段，一个创建时间， 一个删掉时间。 其中创建时间是当前事务的版本号。 删掉时间要么是未定义，要么是大于这个行的
   当前事务版本号。 使用update时会将之前的这行的删掉时间设置一个新版本号，然后新插入一行数据。 
       insert， innodb为新插入的行保存当前系统的版本号作为行版本号，即创建时间， 此时删掉时间设置为未定义。 
       delete， 为删掉的这行设置删掉时间，删掉时间设置为当时系统的版本号。 
       update， 实际上是新插入一个行记录， 创建时间是当前系统的版本号， 设置之前的那行的删掉时间是当前系统的版本号，该行的删掉时间则是未定义。 
       select， 只查找版本早于（包含等于）当前事务的版本的行。 select的行的版本号是当前事务的版本。 
       行的删除时间要么是未定义，要么大于当前事务版本号。 

12. 乐观锁和悲观锁？乐观锁的实现原理? 什么是CAS(compare and swap) ？

13. mysql的分区，分表和分库。 

     mysql单表的数据达到1000w条或者100g时开始要分表和分库了。 

     分表包括 水平分表和垂直分表。
     垂直分表，改变表的结构， 将一个表拆分成多个表结构。 
     水平分表，将数据水平切分，放置在不同的数据库，减少同一个表的数据量。 

     分库。 

     分区。 不改变表的结构，不切分表的数据。 将数据放置到不同的物理机上。 

     面临的问题， 事务， 跨库跨表的join问题。 	

14. redolog日志和binlog日志的区别？
 
     binlog是mysql-server层的日志，可以同步给不同的引擎使用，是逻辑日志，记录是操作写语句。 
     redolog是innodb的日志，叫前滚日志。 是物理日志。 

15. mysql查询语句执行的过程是怎么样？

16. redolog 刷入磁盘的过程？
   
   https://blog.csdn.net/weixin_33730836/article/details/94702163
   redolog是记录事务的前滚日志。 开始事务，执行事务的时候。 redo log buffer 记录redolog的缓冲区。 
   mysql在更新数据的时候，先将数据从磁盘拉到redolog_buffer，在buffer更新完了之后，再写到磁盘里。 
   当数据还在buffer里的时候， 磁盘的数据还不是最新的，也就是脏数据。  

   redo log buffer , redo log file , 磁盘。 
   redo log buffer 只是先刷入redo log file，文件系统是有缓冲区，也就是先刷入到redo log file的缓冲区，这是
   并没有真正的落到磁盘， 而是放在文件的缓冲区。 为了确保redo log 写入磁盘，就通过fsync将数据写入磁盘。 

17. mysql语句优化的方法？

     

18. mvcc如何解决不可重复读和幻读？
    
     mvcc是多版本并发控制，对于每一个事务都有一个事务id，事务之间的id不同，且事务ID是递增的。 
     对于事务里的行操作，包括读和写。 select， insert， update， delete语句的操作。 不可重复读是
     某一个事务两次读操作之间有一个事务发生，并修改了该数据，导致两次读的结果不同。 read-uncommited
     和read-commited 都会产生不可重复读的问题。 使用mvcc可以解决不可重复读的问题。 	
     

redis的重点。 

1. redis的持久化。aof 和 rdb 区别，原理。 aof重写机制。 

    redis的数据存放在内存，为防止服务器宕机，需定期将内存的数据写入磁盘存储，持久化。 
    redis的持久化方式有两种：aof 和 rdb。 

2. redis的主从复制原理。 

3. redis的哨兵机制。 

4. redis的集群机制。 

    redis-cluster的应用场景是海量数据+高并发+高可用。 
    redis-sentinel的应用场景主要是数据量不大的情况，高并发的情况。 
    redis的集群机制使用hash槽实现。总共有16384个hash槽， hash槽是一个逻辑概念，均匀的分布在各个节点。
           例如A B C 3个master节点。 每一个master节点可以有多个slave节点。 
    水平扩容的情况。 加入在当前集群环境中加入一个新的节点D，那么A B C 节点的部分hash槽的数据会移到新
          节点D中，这步是数据迁移，这样增加节点的数量可以增加系统的读写能力。 
    水平缩容的情况。系统中负责某一部分hash槽的master和slave全部宕机了或者想人为的删掉一个master节点
          和对应的slave节点。 那么对应的hash槽会均匀的移到其他节点。 
          在这个过程中受到影响的数据只有一少部分。 

5. redis的一致性哈希。 

6. 雪崩， 击穿， 穿透的解决方案。 

    雪崩， 强调的是一批缓存在一个时间点失效，此时，高并发访问直接打到数据库上，造成数据库宕机。 
               缓存在同一时间大面积失效，大量请求访问直接落到mysql。 
    击穿， 强调的是一个热点key在失效的时间点，被高并发访问，直接打进数据库，造成数据库宕机。 
    穿透， 强调的是人为的刻意的查询不存在的key，这些无效key在缓存和数据库都不存在，造成数据库宕机。

7. redis有哪几种数据过期淘汰策略和内存淘汰策略。

8. 分布式锁的应用场景以及实现。 基于zookeeper以及基于redis二种。 
   
9. 什么是gossip协议款。redis采用gossip协议的优势？

10. 分布式系统的CAP理论。

11. 强一致性，弱一致性和最终一致性的理解。 

12. redis和mysql如何保持数据的一致性，即双写一致性。 

13. 降级和分流。 

分布式重点。 

1. 分布式事务的方案。


   

linux系统。 

1. cpu飙高，怎么排查。

2. 如何排查多线程的死锁。 

